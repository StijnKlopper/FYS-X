// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "/MarchTables.compute"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!






    Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}

struct Node {
    float3 position;
    int vertexIndex;

};

struct ControlNode {
    bool active;
    Node toX, toY, toZ;
};

struct Cube {
    int configuration;
    ControlNode v0, v1, v2, v3, v4, v5, v6, v7;

};

void TriangulateCube(Cube cube) {

    int triangles[16];

    for (int i = 0; i < 16; i++)
    {
        triangles[i] = triangulation[cube.configuration][i];
    }

    Node edges[16];

    for (int i = 0; i < triangles.Length; i++)
    {
        for (int i = 0; i < triangles.Length; i++)
        {

        }
    }


}

struct Triangle
{
    int vertexIndexA;
    int vertexIndexB;
    int vertexIndexC;
    int vertices[100];

    Triangle(int a, int b, int c)
    {
        vertexIndexA = a;
        vertexIndexB = b;
        vertexIndexC = c;

        vertices = new int[3];
        vertices[0] = a;
        vertices[1] = b;
        vertices[2] = c;
    }

    int this[int i]
    {
        get
        {
            return vertices[i];
        }
    }


         bool Contains(int vertexIndex)
        {
            return vertexIndex == vertexIndexA || vertexIndex == vertexIndexB || vertexIndex == vertexIndexC;
        }
}

void AssignVertices(Node points[100]) {

}

void CreateTriangle(Node a, Node b, Node c) {
    triangles.Add(a.vertexIndex);
    triangles.Add(b.vertexIndex);
    triangles.Add(c.vertexIndex);

    Triangle triangle = new Triangle(a.vertexIndex, b.vertexIndex, c.vertexIndex);
    AddTriangleToDictionary(triangle.vertexIndexA, triangle);
    AddTriangleToDictionary(triangle.vertexIndexB, triangle);
    AddTriangleToDictionary(triangle.vertexIndexC, triangle);
}

void MeshFromPoints(Node points[100]) {
    if (points.Length < 1) return;
    AssignVertices(points);
    for (int i = 0; i < points.Length; i += 3)
    {
        CreateTriangle(points[i], points[i + 1], points[i + 2]);
    }
}






void TriangulateCube2(Cube cube)
{
    //int length = TriangleConnectionTable.GetLength(cube.configuration);
    int[] triangles = new int[16];

    for (int i = 0; i < 16; i++)
    {
        triangles[i] = TriangleConnectionTable[cube.configuration, i];
    }
    List<Node> edges = new List<Node>();

    for (int i = 0; i < triangles.Length; i++)
    {
        // For nums between 0 and 11 (12), add edge of cube to meshfrompoints
        switch (triangles[i])
        {
        case -1:
            break;
        case 0:
            edges.Add(cube.centre0);
            break;
        case 1:
            edges.Add(cube.centre1);
            break;
        case 2:
            edges.Add(cube.centre2);
            break;
        case 3:
            edges.Add(cube.centre3);
            break;
        case 4:
            edges.Add(cube.centre4);
            break;
        case 5:
            edges.Add(cube.centre5);
            break;
        case 6:
            edges.Add(cube.centre6);
            break;
        case 7:
            edges.Add(cube.centre7);
            break;
        case 8:
            edges.Add(cube.centre8);
            break;
        case 9:
            edges.Add(cube.centre9);
            break;
        case 10:
            edges.Add(cube.centre10);
            break;
        case 11:
            edges.Add(cube.centre11);
            break;
        }
    }
    MeshFromPoints(edges);

}



void MeshFromPoints2(List<Node> points)
{
    if (points.Count < 1) return;
    AssignVertices(points);
    for (int i = 0; i < points.Count; i += 3)
    {
        CreateTriangle(points[i], points[i + 1], points[i + 2]);
    }
}

void AssignVertices2(List<Node> points)
{
    for (int i = 0; i < points.Count; i++)
    {
        if (points[i].vertexIndex == -1)
        {
            points[i].vertexIndex = vertices.Count;
            vertices.Add(points[i].position);
        }
    }
}

void CreateTriangle2(Node a, Node b, Node c)
{
    triangles.Add(a.vertexIndex);
    triangles.Add(b.vertexIndex);
    triangles.Add(c.vertexIndex);

    Triangle triangle = new Triangle(a.vertexIndex, b.vertexIndex, c.vertexIndex);
    AddTriangleToDictionary(triangle.vertexIndexA, triangle);
    AddTriangleToDictionary(triangle.vertexIndexB, triangle);
    AddTriangleToDictionary(triangle.vertexIndexC, triangle);
}

void AddTriangleToDictionary(int vertexIndexKey, Triangle triangle)
{
    if (triangleDictionary.ContainsKey(vertexIndexKey))
    {
        triangleDictionary[vertexIndexKey].Add(triangle);
    }
    else
    {
        List<Triangle> triangleList = new List<Triangle>();
        triangleList.Add(triangle);
        triangleDictionary.Add(vertexIndexKey, triangleList);
    }
}


